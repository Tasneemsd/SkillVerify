applications.js

const express = require("express");
const router = express.Router();
const jwt = require("jsonwebtoken");
const Application = require("../models/Application");

// POST - apply for job
router.post("/", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, process.env.JWT_SECRET || "supersecret");
    if (decoded.role !== "student") return res.status(403).json({ message: "Only students can apply" });

    const { jobId } = req.body;
    if (!jobId) return res.status(400).json({ message: "Job ID required" });

    const existingApp = await Application.findOne({ studentId: decoded.id, jobId });
    if (existingApp) return res.status(400).json({ message: "Already applied for this job" });

    const application = await Application.create({
      studentId: decoded.id,
      jobId,
      status: "Applied",
      appliedOn: new Date(),
    });

    return res.status(200).json({ success: true, message: "Applied successfully", application });
  } catch (err) {
    console.error("Application error:", err);
    return res.status(500).json({ message: "Application failed", error: err.message });
  }
});

// GET - fetch student applications
router.get("/", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });

    const decoded = jwt.verify(token, process.env.JWT_SECRET || "supersecret");
    if (decoded.role !== "student") return res.status(403).json({ message: "Only students can fetch applications" });

    const applications = await Application.find({ studentId: decoded.id });
    return res.status(200).json(applications);
  } catch (err) {
    console.error("Fetch applications error:", err);
    return res.status(500).json({ message: "Failed to fetch applications" });
  }
});

module.exports = router;


courses.js

const express = require("express");
const Course = require("../models/Course");
const router = express.Router();

// GET /api/courses - get all courses
router.get("/", async (req, res) => {
  try {
    const courses = await Course.find();
    res.json(courses);
  } catch (err) {
    res.status(500).json({ message: "Failed to fetch courses" });
  }
});

// GET /api/courses/id/:courseId - by custom courseId
router.get("/id/:courseId", async (req, res) => {
  try {
    const course = await Course.findOne({ courseId: req.params.courseId });
    if (!course) return res.status(404).json({ error: "Course not found" });
    res.json(course);
  } catch (err) {
    res.status(500).json({ error: "Server error" });
  }
});

// GET /api/courses/:id - by Mongo _id
router.get("/:id", async (req, res) => {
  try {
    const course = await Course.findById(req.params.id);
    if (!course) return res.status(404).json({ error: "Course not found" });
    res.json(course);
  } catch (err) {
    res.status(500).json({ error: "Server error" });
  }
});

module.exports = router;


jobs.js

const express = require("express");
const Job = require("../models/Job");
const Recruiter = require("../models/Recruiter");
const jwt = require("jsonwebtoken");
const router = express.Router();

// PUT /api/jobs/:id - recruiter updates their own job (partial update)
router.put("/:id", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (decoded.role !== "recruiter") return res.status(403).json({ message: "Only recruiters can update jobs" });
    const recruiter = await Recruiter.findOne({ email: decoded.email });
    if (!recruiter) return res.status(404).json({ message: "Recruiter not found" });
    const job = await Job.findById(req.params.id);
    if (!job) return res.status(404).json({ message: "Job not found" });
    if (String(job.postedBy) !== String(recruiter._id)) {
      return res.status(403).json({ message: "You can only update your own jobs" });
    }
    // Only update provided fields
    Object.keys(req.body).forEach(key => {
      if (req.body[key] !== undefined) job[key] = req.body[key];
    });
    await job.save();
    res.json({ message: "Job updated successfully", job });
  } catch (err) {
    res.status(500).json({ message: "Failed to update job", error: err.message });
  }
});

// DELETE /api/jobs/:id - recruiter deletes their own job
router.delete("/:id", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (decoded.role !== "recruiter") return res.status(403).json({ message: "Only recruiters can delete jobs" });
    const recruiter = await Recruiter.findOne({ email: decoded.email });
    if (!recruiter) return res.status(404).json({ message: "Recruiter not found" });
    const job = await Job.findById(req.params.id);
    if (!job) return res.status(404).json({ message: "Job not found" });
    if (String(job.postedBy) !== String(recruiter._id)) {
      return res.status(403).json({ message: "You can only delete your own jobs" });
    }
    await job.deleteOne();
    res.json({ message: "Job deleted successfully" });
  } catch (err) {
    res.status(500).json({ message: "Failed to delete job", error: err.message });
  }
});

// GET /api/jobs/mine - list jobs posted by the logged-in recruiter
router.get("/mine", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (decoded.role !== "recruiter") return res.status(403).json({ message: "Only recruiters can view their jobs" });
    const recruiter = await Recruiter.findOne({ email: decoded.email });
    if (!recruiter) return res.status(404).json({ message: "Recruiter not found" });
    const jobs = await Job.find({ postedBy: recruiter._id }).sort({ postedAt: -1 });
    res.json(jobs);
  } catch (err) {
    res.status(500).json({ message: "Failed to fetch your jobs", error: err.message });
  }
});

// POST /api/jobs - recruiter posts a job/internship
router.post("/", async (req, res) => {
  try {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return res.status(401).json({ message: "No token provided" });
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (decoded.role !== "recruiter") return res.status(403).json({ message: "Only recruiters can post jobs" });
    const recruiter = await Recruiter.findOne({ email: decoded.email });
    if (!recruiter) return res.status(404).json({ message: "Recruiter not found" });
    const job = new Job({
      ...req.body,
      postedBy: recruiter._id,
      postedByEmail: recruiter.email
    });
    await job.save();
    res.json({ message: "Job posted successfully", job });
  } catch (err) {
    res.status(500).json({ message: "Failed to post job", error: err.message });
  }
});

// (Optional) GET /api/jobs - list all jobs
router.get("/", async (req, res) => {
  try {
    const jobs = await Job.find().populate("postedBy", "name email");
    res.json(jobs);
  } catch (err) {
    res.status(500).json({ message: "Failed to fetch jobs" });
  }
});

module.exports = router;

studentEnroll.js

const express = require("express");
const router = express.Router();
const jwt = require("jsonwebtoken");
const Student = require("../models/Student");
const Course = require("../models/Course");

router.post("/", async (req, res) => {
  try {
    const { courseId } = req.body;

    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return res.status(401).json({ success: false, message: "No token provided or invalid format" });
    }

    const token = authHeader.split(" ")[1].replace(/"/g, "");

    let decoded;
    try {
      decoded = jwt.verify(token, process.env.JWT_SECRET || "supersecret");
    } catch (err) {
      return res.status(401).json({ success: false, message: "Invalid or expired token" });
    }

    if (decoded.role !== "student") {
      return res.status(403).json({ success: false, message: "Only students can enroll" });
    }

    const student = await Student.findById(decoded.id);
    const course = await Course.findById(courseId);
    if (!student || !course) {
      return res.status(404).json({ success: false, message: "Student or course not found" });
    }

    if (student.registeredCourses.some((c) => c.toString() === course._id.toString())) {
      return res.status(400).json({ success: false, message: "You are already enrolled in this course" });
    }

    student.registeredCourses.push(course._id);
    await student.save();

    return res.status(200).json({
      success: true,
      message: "Enrolled successfully",
      registeredCourses: student.registeredCourses,
      course,
    });
  } catch (err) {
    console.error("Enroll error:", err);
    return res.status(500).json({ success: false, message: "Something went wrong. Please try again later." });
  }
});

module.exports = router;


index.js

const express = require("express");
const cors = require("cors");
const dotenv = require("dotenv");
const connectDB = require("./config/db");

// Load env vars
dotenv.config({ path: "./.env" });

if (!process.env.MONGO_URI) {
  console.error("âŒ MONGO_URI is missing. Check your .env file.");
  process.exit(1);
} else {
  console.log("âœ… MONGO_URI loaded");
}

// Connect to MongoDB
connectDB();

// Seed dummy courses (optional)
const seedCourses = require("./seed/seedCourses");
seedCourses();

const app = express();

// Enable CORS for frontend
app.use(
  cors({
    origin: ["https://skill-verify.vercel.app"], // frontend domain
    credentials: true,
  })
);

// Body parser
app.use(express.json({ limit: "10mb" }));

// Routes
app.use("/api", require("./routes/auth"));
app.use("/api/courses", require("./routes/courses"));
app.use("/api/jobs", require("./routes/jobs"));
app.use("/api/applications", require("./routes/applications"));
app.use("/api/student", require("./routes/student"));
app.use("/api/student/profile", require("./routes/studentProfile"));
app.use("/api/student/register-course", require("./routes/registerCourse"));
app.use("/api/student/enroll", require("./routes/studentEnroll")); // âœ… student enroll route
app.use("/api/recruiter", require("./routes/recruiter"));
app.use("/api/admin", require("./routes/admin"));
app.use("/api/notification", require("./routes/notification"));
app.use("/api/otp", require("./routes/otp"));

// Default error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: "Server error", error: err.message });
});

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});

Recruiter.js

const mongoose = require("mongoose");

const recruiterSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true }, // hashed password
  companyName: { type: String, default: "" },
  position: { type: String, default: "" },
  phone: { type: String, default: "" },
  bio: { type: String, default: "" },
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model("Recruiter", recruiterSchema);
